#[allow(unused_imports)]
use datafusion_sqlparser::parser::Parser; 
use std::env;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        eprintln!("Error: Please provide a Cypher query string.");
        process::exit(1);
    }

    let query = &args[1];
    let sql = convert_cypher_to_sql(query);
    println!("{}", sql);
}


// Mapping logic cyper to sql
//based on Cypher.g4 grammar
// //trying to do basic crud operations, hopefully not too complicated
fn convert_cypher_to_sql(query: &str) -> String {
    let normalized_query = query.trim();
    let upper_query = normalized_query.to_uppercase();
    
    // Header
    let mut output = String::from("SQL Generated by Rust Transformer\n");
    output.push_str(&format!("/* Source: {} */\n", normalized_query));


    //Create or insert
    if upper_query.starts_with("CREATE") {
        let name = extract_quoted_value(normalized_query, "name:");
        let type_label = extract_label(normalized_query);
        if !name.is_empty() {
             output.push_str(&format!("INSERT INTO nodes (name, type) VALUES ('{}', '{}');", name, type_label));
        } else {
             output.push_str("-- Error parsing CREATE values");
        }
    } 
    //delete
    else if upper_query.contains("DELETE") { 
        let name = extract_quoted_value(normalized_query, "n.name =");
        if !name.is_empty() {
            output.push_str(&format!("DELETE FROM nodes WHERE name = '{}';", name));
        } else {
             output.push_str("-- Error parsing DELETE condition");
        }
    }
    //read w filter 
    else if upper_query.contains("WHERE") { 
        let name = extract_quoted_value(normalized_query, "n.name =");
        if !name.is_empty() {
            output.push_str(&format!("SELECT * FROM nodes WHERE name = '{}';", name));
        } else {
            output.push_str("SELECT * FROM nodes;");
        }
    } 
    //simple read
    else if normalized_query.contains("MATCH (n) RETURN n") {
        println!("SELECT * FROM nodes;");
    }

    //echo/test
    else if normalized_query.contains("RETURN \"Hello\"") {
        println!("SELECT 'Hello' AS message, 'World' AS status;");
    }

    //default
    else {
        println!("SELECT * FROM nodes WHERE name = 'Unknown';");
    }
    
    output
}

fn extract_quoted_value(query: &str, key: &str) -> String {
    if let Some(start_idx) = query.find(key) {
        let rest = &query[start_idx..];
        if let Some(quote_start) = rest.find('\'') {
            let after_quote = &rest[quote_start + 1..];
            if let Some(quote_end) = after_quote.find('\'') {
                return after_quote[..quote_end].to_string();
            }
        }
    }
    String::new()
}

fn extract_label(query: &str) -> String {
    if let Some(colon_idx) = query.find(':') {
        let rest = &query[colon_idx + 1..];
        if let Some(space_idx) = rest.find(' ') {
            return rest[..space_idx].trim().to_string();
        } else if let Some(brace_idx) = rest.find('{') {
             return rest[..brace_idx].trim().to_string();
        }
    }
    return "Node".to_string();
}

// Unit tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_mapping() {
        let cypher = "CREATE (n:Person {name: 'TestUser'})";
        let sql = convert_cypher_to_sql(cypher);
        assert!(sql.contains("INSERT INTO nodes"));
        assert!(sql.contains("VALUES ('TestUser', 'Person')"));
    }

    #[test]
    fn test_select_where_mapping() {
        let cypher = "MATCH (n) WHERE n.name = 'TestUser' RETURN n";
        let sql = convert_cypher_to_sql(cypher);
        assert!(sql.contains("SELECT * FROM nodes WHERE name = 'TestUser'"));
    }
}